/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  See LICENSE.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

// @ts-check
'use strict';

const { execFile } = require('child_process');
const Path = require('path');

const command = process.platform === 'win32' ? 'vsce-sign.exe' : 'vsce-sign';
const vsceSignFilePath = Path.join(__dirname, '..', 'bin', command);

// If this module is in an .asar file, then the binary is unpacked.
const vsceSignOnDiskFilePath = vsceSignFilePath.replace(/\bnode_modules\.asar\b/, 'node_modules.asar.unpacked');

const ExtensionSignatureVerificationCode = {
    'None': 'None',
    'RequiredArgumentMissing': 'RequiredArgumentMissing',
    'InvalidArgument': 'InvalidArgument',
    'PackageIsUnreadable': 'PackageIsUnreadable',
    'UnhandledException': 'UnhandledException',
    'SignatureManifestIsMissing': 'SignatureManifestIsMissing',
    'SignatureManifestIsUnreadable': 'SignatureManifestIsUnreadable',
    'SignatureIsMissing': 'SignatureIsMissing',
    'SignatureIsUnreadable': 'SignatureIsUnreadable',
    'CertificateIsUnreadable': 'CertificateIsUnreadable',
    'SignatureArchiveIsUnreadable': 'SignatureArchiveIsUnreadable',
    'FileAlreadyExists': 'FileAlreadyExists',
    'SignatureArchiveIsInvalidZip': 'SignatureArchiveIsInvalidZip',
    'SignatureArchiveHasSameSignatureFile': 'SignatureArchiveHasSameSignatureFile',

    'Success': 'Success',
    'PackageIntegrityCheckFailed': 'PackageIntegrityCheckFailed',
    'SignatureIsInvalid': 'SignatureIsInvalid',
    'SignatureManifestIsInvalid': 'SignatureManifestIsInvalid',
    'SignatureIntegrityCheckFailed': 'SignatureIntegrityCheckFailed',
    'EntryIsMissing': 'EntryIsMissing',
    'EntryIsTampered': 'EntryIsTampered',
    'Untrusted': 'Untrusted',
    'CertificateRevoked': 'CertificateRevoked',
    'SignatureIsNotValid': 'SignatureIsNotValid',
    'UnknownError': 'UnknownError',
    'PackageIsInvalidZip': 'PackageIsInvalidZip',
    'SignatureArchiveHasTooManyEntries': 'SignatureArchiveHasTooManyEntries',
};

// Must stay in sync with Microsoft.VisualStudio.Extensions.Signing.ReturnCode (https://github.com/microsoft/vsce-sign/blob/main/src/Core/ReturnCode.cs).
const ReturnCode = {};

ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.None] = 0] = ExtensionSignatureVerificationCode.None;  // For internal use.  Used for initialization.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.RequiredArgumentMissing] = 1] = ExtensionSignatureVerificationCode.RequiredArgumentMissing; // A required argument is missing.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.InvalidArgument] = 2] = ExtensionSignatureVerificationCode.InvalidArgument;  // An argument is invalid.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.PackageIsUnreadable] = 3] = ExtensionSignatureVerificationCode.PackageIsUnreadable;  // The extension package is unreadable.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.UnhandledException] = 4] = ExtensionSignatureVerificationCode.UnhandledException; // An unhandled exception occurred.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.SignatureManifestIsMissing] = 5] = ExtensionSignatureVerificationCode.SignatureManifestIsMissing; // The extension is missing a signature manifest file (.signature.manifest).
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.SignatureManifestIsUnreadable] = 6] = ExtensionSignatureVerificationCode.SignatureManifestIsUnreadable; // The signature manifest is unreadable.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.SignatureIsMissing] = 7] = ExtensionSignatureVerificationCode.SignatureIsMissing; // The extension is missing a signature file (.signature.p7s).
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.SignatureIsUnreadable] = 8] = ExtensionSignatureVerificationCode.SignatureIsUnreadable; // The signature is unreadable.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.CertificateIsUnreadable] = 9] = ExtensionSignatureVerificationCode.CertificateIsUnreadable; // The certificate is unreadable.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.SignatureArchiveIsUnreadable] = 10] = ExtensionSignatureVerificationCode.SignatureArchiveIsUnreadable; // The signature archive is unreadable.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.FileAlreadyExists] = 11] = ExtensionSignatureVerificationCode.FileAlreadyExists; // The output file already exists.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.SignatureArchiveIsInvalidZip] = 12] = ExtensionSignatureVerificationCode.SignatureArchiveIsInvalidZip; // The signature archive is not valid ZIP format.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.SignatureArchiveHasSameSignatureFile] = 13] = ExtensionSignatureVerificationCode.SignatureArchiveHasSameSignatureFile; // The signature archive has the same signature file.

// Space reserved for additional CLI-specific return codes.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.Success] = 100] = ExtensionSignatureVerificationCode.Success; // The operation succeeded.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.PackageIntegrityCheckFailed] = 101] = ExtensionSignatureVerificationCode.PackageIntegrityCheckFailed; // The package integrity check failed.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.SignatureIsInvalid] = 102] = ExtensionSignatureVerificationCode.SignatureIsInvalid; // The extension has an invalid signature file (.signature.p7s).
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.SignatureManifestIsInvalid] = 103] = ExtensionSignatureVerificationCode.SignatureManifestIsInvalid; // The extension has an invalid signature manifest file (.signature.manifest).
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.SignatureIntegrityCheckFailed] = 104] = ExtensionSignatureVerificationCode.SignatureIntegrityCheckFailed; // The extension's signature integrity check failed.  Extension integrity is suspect.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.EntryIsMissing] = 105] = ExtensionSignatureVerificationCode.EntryIsMissing; // An entry referenced in the signature manifest was not found in the extension.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.EntryIsTampered] = 106] = ExtensionSignatureVerificationCode.EntryIsTampered; // The integrity check for an entry referenced in the signature manifest failed.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.Untrusted] = 107] = ExtensionSignatureVerificationCode.Untrusted; // An X.509 certificate in the extension signature is untrusted.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.CertificateRevoked] = 108] = ExtensionSignatureVerificationCode.CertificateRevoked; // An X.509 certificate in the extension signature has been revoked.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.SignatureIsNotValid] = 109] = ExtensionSignatureVerificationCode.SignatureIsNotValid; // The extension signature is invalid.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.UnknownError] = 110] = ExtensionSignatureVerificationCode.UnknownError; // An unknown error occurred.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.PackageIsInvalidZip] = 111] = ExtensionSignatureVerificationCode.PackageIsInvalidZip; // The extension package is not valid ZIP format.
ReturnCode[ReturnCode[ExtensionSignatureVerificationCode.SignatureArchiveHasTooManyEntries] = 112] = ExtensionSignatureVerificationCode.SignatureArchiveHasTooManyEntries; // The signature archive has too many entries.

class ExtensionSignatureVerificationResult {
    /**
     * @param {string} code
     * @param {boolean} didExecute
     * @param {string | undefined} output
     */
    constructor(code, didExecute, output) {
        this.code = code;
        this.didExecute = didExecute;
        this.output = output;
    }
}

/**
 * @param {string} vsixFilePath
 * @param {string} signatureArchiveFilePath
 * @param {boolean} verbose
 * @returns {Promise<ExtensionSignatureVerificationResult>}
 */
async function verify(vsixFilePath, signatureArchiveFilePath, verbose) {
    const args = ['verify', '--package', vsixFilePath, '--signaturearchive', signatureArchiveFilePath];
    return await execCommand(args, verbose, false);
}

/**
 * @param {string} vsixFilePath
 * @param {string | undefined} manifestFilePath
 * @param {boolean} verbose
 * @returns {Promise<string>}
 */
async function generateManifest(vsixFilePath, manifestFilePath, verbose) {
    const args = ['generatemanifest', '--package', vsixFilePath];

    if (typeof manifestFilePath === 'string') {
        args.push('--output');
        args.push(manifestFilePath);
    }

    await execCommand(args, verbose, true);

    return manifestFilePath ?? Path.join(Path.dirname(vsixFilePath), '.signature.manifest');
}

/**
 * @param {string} manifestFilePath
 * @param {string} signatureFilePath
 * @param {string | undefined} signatureArchiveFilePath
 * @param {boolean} verbose
 * @returns {Promise<string>}
 */
async function zip(manifestFilePath, signatureFilePath, signatureArchiveFilePath, verbose) {
    const args = ['zip', '--manifest', manifestFilePath, '--signature', signatureFilePath];

    if (typeof signatureArchiveFilePath === 'string') {
        args.push('--output');
        args.push(signatureArchiveFilePath);
    }

    await execCommand(args, verbose, true);

    return signatureArchiveFilePath ?? Path.join(Path.dirname(manifestFilePath), '.signature.zip');
}

/**
 * @param {string[]} args
 * @param {boolean} verbose
 * @param {boolean} throwIfNotSuccess
 * @returns {Promise<ExtensionSignatureVerificationResult>}
 */
function execCommand(args, verbose, throwIfNotSuccess) {
    return new Promise((resolve, reject) => {

        if (verbose === true) {
            args.push('--verbose');
        }

        execFile(vsceSignOnDiskFilePath, args, (error, stdout) => {
            let returnCode;
            let didExecute = false;

            // vsce-sign never returns 0, and execFile(...) returns an error for any non-zero exit code.
            const code = error?.code;
            const output = verbose ? stdout : undefined;

            // vsce-sign returns exit codes (numbers), whereas execFile(...), in the absence of an exit code, returns an error code (string) (e.g.:  ENOENT).
            if (typeof code === 'number') {
                didExecute = true;
                returnCode = ReturnCode[code];
            } else if (typeof code === 'string') {
                returnCode = code;
            }

            returnCode = returnCode ?? ExtensionSignatureVerificationCode.UnknownError;

            if (throwIfNotSuccess && returnCode !== ExtensionSignatureVerificationCode.Success) {
                reject(new ExtensionSignatureVerificationResult(returnCode, didExecute, output));
                return;
            }

            resolve(new ExtensionSignatureVerificationResult(returnCode, didExecute, output));
        });
    });
}

module.exports = {
    verify,
    generateManifest,
    zip,
    ReturnCode,
    ExtensionSignatureVerificationCode,
    ExtensionSignatureVerificationResult
};